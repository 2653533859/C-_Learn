# 数据结构综合指南

> 本指南按照学习路径进行分节式讲解，配合示意图与代码索引，帮助你在脑海中建立数据结构 + 算法 + 内存布局的统一模型。

---

## 1. 数组与字符串

### 1.1 核心概念
- **数组 (Array)**：一段连续内存，元素类型固定，通过下标 (index) 随机访问。
- **字符串 (String)**：以字符数组为载体，以 `\0` 作为结束符的 C 语言风格文本。

### 1.2 内存布局
```
基址 (base) → ┌──────┬──────┬──────┬──────┐
              │a[0] │a[1] │a[2] │a[3] │  连续字节
              └──────┴──────┴──────┴──────┘
                                        ↑
                              a + i*sizeof(T)
```
> 字符串在末尾额外存储 `\0`，算长度时需要排除。

### 1.3 操作与复杂度
| 操作             | 时间复杂度 | 说明                              |
|------------------|------------|-----------------------------------|
| 随机访问 `a[i]`  | `O(1)`     | 通过基址 + 偏移完成               |
| 插入/删除        | `O(n)`     | 需要移动元素保持连续              |
| 遍历/查找        | `O(n)`     | 顺序访问，最好配合缓存友好设计    |

### 1.4 适用场景
- 数据规模稳定、访问模式以随机访问为主。
- 需要与底层硬件或外设直接交互（如缓冲区操作）。

### 1.5 常见错误
- 越界访问：错误索引或忘记预留结尾 `\0`。
- 指针衰退：函数参数退化为指针，无法获知数组长度。

➡ 参考代码：`examples/array_string_demo.c`

---

## 2. 结构体与联合体

### 2.1 结构体 (struct)
- 通过将**不同类型**的成员打包，描述问题域中的复合对象。
- 支持嵌套、指针与数组成员。

### 2.2 联合体 (union)
- 多个成员公用**同一段内存**，同时只能激活一个成员。
- 常见于节省空间、实现类型擦除（例如泛型容器）。

### 2.3 内存对齐示意
```
struct Packet {
    uint16_t header;   // 2 字节
    uint8_t  type;     // 1 字节 + 1 字节填充
    uint32_t length;   // 4 字节
};
```
> 为满足对齐，编译器会插入填充字节 (padding)。使用 `sizeof` 验证布局。

### 2.4 设计建议
- 优先使用结构体表达真实世界实体。
- 若需共享内存或构建变体类型，再考虑联合体。
- 针对跨平台场景，显式指定字节对齐（`#pragma pack` 或 `__attribute__((packed))`）。

➡ 参考代码：`examples/array_string_demo.c` 中的 `Student` 结构体示例。

---

## 3. 单/双链表

### 3.1 节点结构
```
单链表： data | next →
双链表： prev ← data → next
```

### 3.2 内存特点
- 节点通过堆分配，彼此不连续，由指针维护顺序。
- 插入/删除无需移动其他节点，只需更新指针。

### 3.3 复杂度一览
| 操作                 | 单链表      | 双链表      |
|----------------------|-------------|-------------|
| 头插/头删            | `O(1)`      | `O(1)`      |
| 尾插/尾删            | `O(n)`      | `O(1)` (需尾指针) |
| 按值查找             | `O(n)`      | `O(n)`      |
| 按位置随机访问       | `O(n)`      | `O(n)`      |

### 3.4 调试技巧
- 使用“乌龟兔子”指针 (`slow/fast`) 检测环。
- 打印节点地址与 `next` 指针，有助于定位断链问题。

➡ 参考代码：`examples/linked_list.c`

---

## 4. 栈与队列

### 4.1 栈 Stack（后进先出 LIFO）
```
          Push ↑
┌──────┐
│  top │ → 指向下一个可写入位置
└──────┘
          Pop  ↓
```
- 常见应用：函数调用栈、表达式求值、撤销操作。
- 支持顺序存储（数组）或链式存储（链表）。

### 4.2 队列 Queue（先进先出 FIFO）
```
front → [ a0 ][ a1 ][ a2 ] ← rear
             出队       入队
```
- 常见应用：任务调度、缓冲器、BFS 宽度优先搜索。
- 循环队列可高效复用数组空间。

### 4.3 操作复杂度
| 数据结构 | 入队/压栈 | 出队/弹栈 | 查看队首/栈顶 |
|----------|-----------|-----------|----------------|
| 数组栈   | `O(1)`    | `O(1)`    | `O(1)`         |
| 链表栈   | `O(1)`    | `O(1)`    | `O(1)`         |
| 循环队列 | `O(1)`    | `O(1)`    | `O(1)`         |
| 链表队列 | `O(1)`    | `O(1)`    | `O(1)`         |

➡ 参考代码：`examples/stack_queue.c`

---

## 5. 二叉树基础

### 5.1 定义
- 每个节点最多拥有两个子节点（左、右）。
- 常见变体：完全二叉树、二叉搜索树 (BST)、平衡树。

### 5.2 结构示意
```
        (10)
       /    \
    (5)      (15)
    / \      /  \
 (2)  (7) (12) (20)
```

### 5.3 核心操作
- **遍历**：前序 (根→左→右)、中序 (左→根→右)、后序 (左→右→根)、层序 (BFS)。
- **插入/查找**：对于 BST，左子树小于根，右子树大于根。
- **高度/节点统计**：递归或迭代。

### 5.4 复杂度
| 操作   | 最佳       | 最差（退化为链表） |
|--------|------------|--------------------|
| 插入   | `O(log n)` | `O(n)`             |
| 查找   | `O(log n)` | `O(n)`             |
| 遍历   | `O(n)`     | `O(n)`             |

### 5.5 可视化与调试
- 利用中序遍历输出节点，可验证 BST 性质。
- 使用层序打印或“旋转”树形 ASCII 图，直观展示结构。

➡ 参考代码：`examples/binary_tree.c`

---

## 6. 学习小结
- **思维模型**：先画图（结构/指针/索引） → 写伪代码 → 实现 → 测试。
- **调试工具**：`gdb` 单步调试、`valgrind` 检查内存、在线可视化工具（如 graphviz）。
- **迁移能力**：掌握原理后，可拓展到 STL 容器、并发安全容器、自定义内存管理等高级主题。

> 推荐实践：阅读示例代码时，尝试手动修改参数或插入错误，再使用调试工具定位问题，加深对抽象数据结构的体感。
